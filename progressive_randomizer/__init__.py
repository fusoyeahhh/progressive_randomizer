import pprint

import csv
import random
import re

from dataclasses import dataclass

import logging
log = logging.getLogger()

class WriteQueue:
    def __init__(self, seed=0):
        self._write_queue = []
        self._history = {}

        # TODO: make this consistent
        self._seed = seed

    def flush(self, bindata):
        # FIXME: use decompile / compile, e.g., JSON schematic
        while len(self._write_queue) > 0:
            patcher = self._write_queue.pop(0)
            # TODO: detect collisions (has to be done in rando)
            # TODO: need a way to chain splice
            bindata = patcher >> bindata
            # TODO: annotate history
        return bindata

    def queue_write(self, patcher):
        self._write_queue.append(patcher)

@dataclass(repr=True, init=True)
class MemoryStructure:
    addr: int
    length: int
    name: str
    descr: str

    # syntactic sugar for write
    @dataclass
    class Payload:
        addr: int
        payload: bytes

        def __rshift__(self, bindata):
            """
            # rom = struct | b"\xff\xff" >> rom
            """
            left = bindata[:self.addr]
            right = bindata[self.addr + len(self.payload):]
            return bytes(left + self.payload + right)

    def __matmul__(self, bindata):
        return self.patch(bindata)

    def patch(self, data, bindata=None):
        assert len(data) == self.length, f"0x{self.addr:x}+{self.length}"
        if bindata is None:
            return self.Payload(addr=self.addr, payload=data)
        return self.Payload(addr=self.addr, payload=data) >> bindata

    # syntactic sugar for read
    def __lshift__(self, bindata):
        return self.read(bindata)

    def read(self, bindata):
        assert 0 <= self.addr < len(bindata)
        log.info(f"Reading 0x{self.length:x} bytes of data "
                 f"starting at 0x{self.addr:x}")
        return bytes(bindata[self.addr:self.addr+self.length])

    # TODO: Need decompress / recompress routine from BC
    def map(self, fcn):
        pass

class AssemblyObject(MemoryStructure):
    OP_REF = {}
    with open("etc/snes_op_code_ref.csv", "r") as fin:
        OP_REF = {int(item[3], base=16): (item[0], int(item[-2][0]))
                  for item in csv.reader(fin.readlines())}

    @classmethod
    def _disassemble(cls, prg_bytes):
        disassembly = []
        prg_bytes = [*prg_bytes]
        while len(prg_bytes) > 0:
            op = prg_bytes.pop(0)
            oplen = cls.OP_REF[op][-1]
            args, prg_bytes = prg_bytes[:oplen], prg_bytes[oplen:]
            disassembly.append([op, args])

        return disassembly

    def annotate(self, bindata):
        prg = ""
        pad = max([len(op[0]) for op in self.OP_REF.values()])
        for op, args in self._disassemble(self.read(bindata)):
            op_name = self.OP_REF[op][0]
            args = " ".join([str(arg).rjust(3) for arg in args])
            prg += f"{op_name.ljust(pad)} {args}\n"
        return prg

    def identify_pointers(self, bindata):
        pass

class Registry:
    def __init__(self):
        self._blocks = {}
        # TODO: make into interval tree
        self._tree = {}
        from collections import defaultdict
        self._tags = defaultdict(set)

    def register_block(self, addr, length, name, descr, tags=set()):
        if name in self._blocks:
            return self._blocks[name]

        block = MemoryStructure(addr, length, name, descr)
        span = (addr, addr + length)
        self._blocks[name] = self._tree[span] = block

        for tag in tags:
            self._tags[tag].add(name)

        return block

    def __str__(self):
        return pprint.pformat(self._blocks)

class StaticRandomizer:
    def __init__(self):
        self._reg = Registry()

    def __getitem__(self, item):
        if not isinstance(item, tuple):
            item = (item,)

        if item[0] in self._reg._blocks:
            return self._reg._blocks[item[0]]
        elif len(item) != 3:
            raise KeyError(f"Block key {item[0]} not found in registry.")

        beg, end = item[1:]
        name = f"0x{beg:x}_0x{end:x}"
        descr = f"Autogenerated alias for block {name}"

        return self._reg.register_block(beg=beg, length=end - beg,
                                        name=name, descr=descr)

    @classmethod
    def from_rom_map(cls, rommap, tags=set(), apply_offset=0):
        reg = Registry()
        with open(rommap, "r", encoding="utf-8") as fin:
            for beg, end, descr in csv.reader(fin.readlines()):
                beg = int(beg, base=16) - apply_offset
                end = int(end, base=16) - apply_offset + 1

                # make a shorter memorable name
                name = re.sub(r'\([^()]*\)', "", descr)
                name = "_".join([word[0] + re.sub(r"[aeiou]", "", word[1:], flags=re.I)[:4]
                                 for word in name.lower().strip().split(" ")])
                name = re.sub(r"[/']", "_", name, flags=re.I)
                _tags = set(descr.lower().split()) & tags

                if name in reg._blocks:
                    i = 0
                    while name + str(i) in reg._blocks:
                        i += 1
                    name = name + str(i)

                reg.register_block(beg, end - beg, name, descr, _tags)

        return reg

    def decompile(self, bindata, fill_gaps=True):
        known = {name: blk << bindata for name, blk in self._reg._blocks.items()}
        # TODO: get all undocumented sections
        return known

    def compile(self, mmap, fill=b'\x00', binsize=None):
        # TODO: check full coverage of all blocks
        # TODO: fill gaps
        # TODO: remap pointers
        bindata = b""
        for name, blk in sorted(mmap, key=lambda blk: len(blk[-1])):
            log.debug(f"Writing {len(blk)} bytes for section {name}")
            bindata += bytes(blk)

        pad = (binsize or len(bindata)) - len(bindata)
        assert pad >= 0
        return bindata + fill * pad

#
# FF6 specifics
#

class FF6StaticRandomizer(StaticRandomizer):
    ROM_MAP_DATA = "etc/ff6_rom_map.csv"
    ROM_DESCR_TAGS = {"unused", "compressed", "pointers", "data", "names",
                      "descriptions", "program", "code", "ending", "font", "script",
                      "balance", "ruin", "world",
                      "item", "attack", "battle", "scripts", "attack",
                      "esper", "lores", "spell", "magic",
                      "blitz", "swdtech", "dance", "sketch", "rage"}

    def __init__(self):
        super().__init__()
        self._reg = StaticRandomizer.from_rom_map(self.ROM_MAP_DATA,
                                                  self.ROM_DESCR_TAGS,
                                                  apply_offset=0xC00000)

    def __getitem__(self, item):
        # semantic behavior --- applying tags will produce different object
        # reads
        bare = super().__getitem__(item)
        if item in self._reg._tags.get("names", set()) | \
                   self._reg._tags.get("descriptions", set()):
                return FF6Text.from_super(bare)
        elif item in self._reg._tags.get("pointers", set()):
            return FF6PointerTable.from_super(bare)
        elif item in self._reg._tags.get("data", set()):
            return FF6DataTable.from_super(bare)
        elif item in self._reg._tags.get("program", set()):
            return AssemblyObject(bare.addr, bare.length, bare.name, bare.descr)

        return bare

    def write(self, *args):
        # section, data, section, data, etc...
        pass

    # utils
    CHAR_NAME_LEN = 6
    def get_char_names(self, bindata, nbytes=CHAR_NAME_LEN):
        cnames_raw = self["chrct_nms"] << bindata
        return [cnames_raw[i * nbytes: (i + 1) * nbytes]
                    for i in range(len(cnames_raw) // nbytes)]

    def get_unused_space_blks(self):
        return [self[k] for k in self._reg._tags.get("unused", [])]

class FF6Text(MemoryStructure):
    # Upper case
    _CHARS = {128 + i: chr(j) for i, j in enumerate(range(65, 65 + 26))}
    # Lower case
    _CHARS.update({154 + i: chr(j) for i, j in enumerate(range(97, 97 + 26))})
    # Numbers
    _CHARS.update({180 + i: chr(j) for i, j in enumerate(range(48, 48 + 10))})
    # FIXME: Will probably need symbols at some point
    _CHARS[190] = "!"
    _CHARS[191] = "?"
    _CHARS[193] = ":"
    _CHARS[195] = "'"
    _CHARS[196] = "-"
    _CHARS[197] = "."
    _CHARS[198] = ","
    _CHARS[0xd3] = "["
    _CHARS[0xc2] = "]"
    _CHARS[199] = "..."  # ellipsis character
    _CHARS[255] = " "

    @classmethod
    def from_super(cls, mem_struct):
        return cls(mem_struct.addr, mem_struct.length,
                   mem_struct.name, mem_struct.descr)

    @classmethod
    def _decode(cls, word):
        return "".join([cls._CHARS.get(i, "?") for i in word])

    #@classmethod
    #def _decode_stream(cls, words, sep=None):
        #return [cls._deocde(word) for word in words.split(sep)]

    @classmethod
    def _encode(cls, word):
        pass

    def patch(self, text, bindata):
        return super().patch(self._encode(text), bindata)

    def read(self, bindata):
        return self._decode(super().read(bindata))

# dataclass?
class FF6PointerTable(MemoryStructure):
    def __init__(self, ptr_size=2, **kwargs):
        super().__init__(**kwargs)
        self.ptr_size = ptr_size

    # FIXME: this shouldn't know or care about its offset
    # it might need to know if we did automatic linkage...
    # We also need to find a more consistent way to handle the 0xC00000
    @classmethod
    def maybe_parse_offset(cls, descr):
        try:
            return int(re.search(r'\$([C-F][0-9A-Fa-f]+)', descr).group(1), base=16) - 0xC00000
        except (AttributeError, IndexError):
            pass
        return 0

    @classmethod
    def from_super(cls, mem_struct, ptr_size=2):
        return cls(ptr_size,
                   addr=mem_struct.addr, length=mem_struct.length,
                   name=mem_struct.name, descr=mem_struct.descr)

    def read(self, bindata):
        import struct
        raw_data = super().read(bindata)
        return struct.unpack("<" + "H" * (len(raw_data) // 2), raw_data)

class FF6DataTable(MemoryStructure):
    def __init__(self, item_size=None, **kwargs):
        super().__init__(**kwargs)
        self.item_size = item_size

    @classmethod
    def maybe_parse_size(cls, descr):
        try:
            return int(re.search(r'([0-9]+) bytes', descr).group(1))
        except (AttributeError, IndexError):
            pass
        return None

    @classmethod
    def from_super(cls, mem_struct, item_size=None):
        return cls(item_size or cls.maybe_parse_size(mem_struct.descr),
                   addr=mem_struct.addr, length=mem_struct.length,
                   name=mem_struct.name, descr=mem_struct.descr)

    # make a PointerTable object
    def to_ptr_table(self, addr):
        # FIXME: won't work for variable length
        tbl_length = self.length // self.item_size
        return FF6PointerTable(addr=addr, length=tbl_length, name="", descr="")

    def dereference(self, bindata, ptr_tbl=None):
        assert self.item_size is not None or ptr_tbl is not None
        raw_data = super().read(bindata)

        if self.item_size is not None:
            nitems = self.length // self.item_size
            itrs = [i * self.item_size for i in range(nitems + 1)]
        else:
            itrs = [ptr for ptr in ptr_tbl.read(bindata)] + [self.length]

        return [bytes(raw_data[i:j]) for i, j in zip(itrs[:-1], itrs[1:])]

# Randomization tasks
class RandomizationTask:
    def __call__(self, bindata):
        return self._memblk << bindata

    def __rshift__(self, bindata):
        data = self(bindata)
        return self._memblk @ bytes(data) >> bindata

class ShuffleBytes(RandomizationTask):
    def __init__(self, memblk):
        self._memblk = memblk

    def __call__(self, bindata):
        import random
        data = super().__call__(bindata)
        return random.sample(list(data), k=len(data))
TASKS = {
    "shuffle_bytes": ShuffleBytes,
}

#
# Progressive stuff
#
class QueueController(WriteQueue):
    pass

class ProgressiveRandomizer(StaticRandomizer):
    def __init__(self):
        self._q = QueueController()