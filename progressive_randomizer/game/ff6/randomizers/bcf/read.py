import sys
import os
import json
import time
import logging
logging.basicConfig(stream=sys.stdout, level=logging.INFO)

def read_spoiler(spoilerf):
    """
    Read and parse the spoiler file generated by BC. Generates a mapping of sprite / character as well as music information.

    :param spoilerf: Path to the spoiler file.
    :return: A tuple of three items: the flags (string), the seed (string), and a tuple of the character sprite and music maps.
    """
    with open(spoilerf) as fout:
        lines = fout.readlines()

    # Get seed
    #_, _, flags, seed = lines[0].split(".")
    #seed = seed.strip()
    # FIXME: this appears to be no longer recorded
    flags, seed = None, None

    # Skip to characters section
    line = lines.pop(0)
    while "CHARACTERS" not in line:
        line = lines.pop(0)
    # Drop two blank lines
    lines = lines[2:]

    # Parse character information
    char_map = []
    while True:
        # Mapping information for a single character
        _map = {}
        # Line to parse
        line = lines.pop(0)

        # This is our stopping condition. The line contains no index number to parse
        try:
            id, _map["cname"] = line.split(" ")
            # If this doesn't parse, it throws an exception and we break out
            int(id.replace(".", ""))
        except ValueError:
            break

        # New character name
        _map["cname"] = _map["cname"].strip()
        lines.pop(0)
        # New sprite
        _map["appearance"] = lines.pop(0).replace("Looks like: ", "").strip()
        # Original character name
        _map["orig"] = lines.pop(0).split(" ")[-1].strip().lower()
        char_map.append(_map)
        # Skip empty lines until the next processable line
        while line.strip() != "":
            line = lines.pop(0)
    
    # extra NPCs
    while "AESTHETICS" not in line:
        line = lines.pop(0)
    lines = lines[2:]

    # Opera character information
    opera = {}
    line = lines.pop(0)
    while line.strip() != "":
        orig_char, new_char = line.split(":")
        if "Opera" in line:
            opera[orig_char.replace("Opera", "").strip()] = new_char.strip()
        else:
            char_map.append({"cname": "",
                             "orig": orig_char.strip().lower(),
                             "appearance": new_char.strip()})
        line = lines.pop(0)

    # Add an entry for the opera itself
    opera = " | ".join([f"{k} -> {v}" for k, v in opera.items()])
    char_map.append({"cname": "Opera", "orig": "opera", "appearance": opera})

    # Other NPCs
    line = lines.pop(0)
    while line.strip() != "":
        orig_char, new_char = [s.strip() for s in line.split(":")]
        orig_char = orig_char.lower()
        if orig_char not in {c["orig"] for c in char_map}:
            char_map.append({"cname": "", "orig": orig_char, "appearance": new_char})
        line = lines.pop(0)    

    # Skip to music section
    line = lines.pop(0)
    while "MUSIC" not in line:
        line = lines.pop(0)
    lines = lines[2:]

    music_map = []
    while True:
        # Mapping information for a single song
        _map = {}
        music_map.append(_map)
        line = lines.pop(0)

        # This is the indicator that there's a mapping to process
        if "->" not in line:
            break

        line, mapped = line.split("->")
        mapped = mapped.strip()
        sid, mapping = map(str.strip, line.split("."))
        # Integer song ID
        _map["song_id"] = int(sid)
        # New song name
        _map["new"] = mapped
        # Original song name
        _map["orig"] = mapping

        _map["descr"] = lines.pop(0).strip()

        # Song composer / arranger information
        line = lines.pop(0).strip()
        _map["descr"] += " | " + line
        line = lines.pop(0).strip()
        _map["descr"] += " | " + line

        # If there is no additional information, continue to next entry
        if lines[0].strip() == "":
            continue

        # Jukebox title
        line = lines.pop(0).strip()
        _map["descr"] += " " + line

        # Skip blank line
        lines.pop(0)

    return flags, seed, (music_map, char_map)

def read_remonstrate(fname):
    with open(fname) as fout:
        lines = fout.readlines()

    # Drop header
    lines = lines[2:]

    return {
        "enemy_id": [int(line[:3], base=16) for line in lines],
        "sprite": [line[4:].replace("/", " | ").strip().replace(".png", "").replace(".PNG", "")
                                                                for line in lines]
    }
